\input{preamble}

\begin{document}
\section{Klassiker}
\subsection{Merge Sort}
\SidebarCite{gh:tikzpingus}

{
\def\List{\textcolor{gray}{List}}%
\def\paramstyle#1{\textup{#1}}
\def\list{\paramstyle{list}}\def\a{\paramstyle{a}}\def\b{\paramstyle{b}}
\def\varstyle#1{\textup{#1}}
\def\le{\varstyle{left}}\def\x{\varstyle{x}}\def\ri{\varstyle{right}}\def\me{\varstyle{merged}}

\savebox\pinguA{\tikz{\pingu[wings wave,eyes wink]}}%

% temp saveboxes
\tikzset{
    KK/.style={
        /pingu/@block/.append style={fill=##1!35!white},
        /pingu/@draw/.append style={draw=##1!35!white}
    }
}
\newsavebox\PinguMsSeven
\savebox\PinguMsSeven{\tikz{\pingu[wings wave,name=p,eyes shiny,hat,KK]; \node[scale=1.5] at(p-belly-center) {\huge7};}}
\newsavebox\PinguMsEleven
\savebox\PinguMsEleven{\tikz{\pingu[wings hug,name=p,eyes wink,headband,KK]; \node[scale=1.5] at(p-belly-center) {\huge11};}}
\newsavebox\PinguMsNineteen
\savebox\PinguMsNineteen{\tikz{\pingu[right wing raise,name=p,:devil,hand cast right=\textcolor{pingu@purple!35!white}{\faWindows},KK]; \node[scale=1.5] at (p-belly-center) {\huge19};}}
\newsavebox\PinguMsZero
\savebox\PinguMsZero{\tikz{\pingu[monocle left,right wing grab,right eye angry,name=p,halo=paletteA,KK]; \node[scale=1.5] at(p-belly-center) {\huge0};}}
\newsavebox\PinguMsFour
\savebox\PinguMsFour{\tikz{\pingu[sunglasses,small,eyes shock,wings shock,name=p,cake-hat,cake-hat top=paletteB,KK]; \node[scale=1.5] at(p-belly-center) {\huge4};}}

\begin{frame}{Merge Sort an sich}
\begin{columns}[c]
\column{.6\linewidth}
\footnotesize
\begin{algorithm}[H]
\PreCode\StartCode
\onslide<2->{\Function{sort(\list: \List) \(\to\) \List}{
    \onslide<4->{\lIf{\textit{len} \(\list \leq 1\)}{\KwRet{\list}}}
\smallskip
    \onslide<5->{\le, \ri\ \(\gets\) \textit{split}(\list)\;}

    \onslide<7->{\KwRet~}\onslide<6->{\(\textit{merge}\bigl(\textit{sort}(\le),~\textit{sort}(\ri)\bigr)\)\;}
}}
\bigskip
\onslide<3->{\Function{merge(\a: \List, \b: \List) \(\to\) \List}{
    \onslide<8->{\me\ \(\gets\) empty List\;}
    \smallskip
    \onslide<9->{\While{\a\ \& \b\ aren't empty}{
        \onslide<10->{\(\x \gets \a[0] \leq \b[0]\) \KwSty{?} \a\ \KwSty{:} \b\;}
        \onslide<11->{\me.add(\x.remove(\(0\)))\;}
    }}
    \smallskip
    \onslide<13->{\me.add(}\onslide<12->{\textit{\a\ not empty} \KwSty{?} \a\ \KwSty{:} \b}\onslide<13->{)\;}
    \onslide<14->{\KwRet\me\;}
}}
\end{algorithm}
\column{.375\linewidth}
\resizebox\linewidth!{\begin{tikzpicture}
    \foreach[count=\i] \p in {Eleven,Seven,Nineteen,Four,Zero} {
        \onslide<\the\numexpr15+\i\relax->{
            \node[scale=.33,above] (\i) at (1.25*\i, 0) {\expandafter\usebox\csname PinguMs\p\endcsname};
        }
    }
    \onslide<21->{
        \draw[decoration={brace,mirror},decorate] (1.south west|-0,0) to (3.south east|-0,0);
        \draw[decoration={brace,mirror},decorate] (4.south west|-0,0) to (5.south east|-0,0);
    \foreach[count=\i] \p in {Eleven,Seven,Nineteen,Four,Zero} {
        \node[scale=.33,above] (\i) at (1.25*\i, -1.25) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
    \onslide<22->{
        \foreach \a/\b in {1/2,3/3,4/4,5/5}{
            \draw[decoration={brace,mirror},decorate] (\a.south west|-0,-1.25) to (\b.south east|-0,-1.25);
        }
    \foreach[count=\i] \p in {Eleven,Seven,Nineteen,Four,Zero} {
        \node[scale=.33,above] (\i) at (1.25*\i, -2.5) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
    \onslide<23->{
        \foreach \a/\b in {1/1,2/2,3/3,4/4,5/5}{
            \draw[decoration={brace,mirror},decorate] (\a.south west|-0,-2.5) to (\b.south east|-0,-2.5);
        }
    \foreach[count=\i] \p in {Eleven,Seven,Nineteen,Four,Zero} {
        \node[scale=.33,above] (\i) at (1.25*\i, -3.75) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
    \pgfonlayer{background}
    \onslide<24->{
        \draw[line cap=round,line width=2mm,gray!20!white] ([xshift=-1mm]1.west) -- ([xshift=1mm]5.east);
    }
    \endpgfonlayer
    \onslide<25->{
        \foreach \a/\b in {1/2,3/3,4/5}{
            \draw[decoration={brace,mirror},decorate] (\a.south west|-0,-3.75) to (\b.south east|-0,-3.75);
        }
    \foreach[count=\i] \p in {Seven,Eleven,Nineteen,Zero,Four} {
        \node[scale=.33,above] (\i) at (1.25*\i, -5) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
    \onslide<26->{
        \foreach \a/\b in {1/3,4/5}{
            \draw[decoration={brace,mirror},decorate] (\a.south west|-0,-5) to (\b.south east|-0,-5);
        }
    \foreach[count=\i] \p in {Seven,Eleven,Nineteen,Zero,Four} {
        \node[scale=.33,above] (\i) at (1.25*\i, -6.25) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
    \onslide<27->{
        \foreach \a/\b in {1/5}{
            \draw[decoration={brace,mirror},decorate] (\a.south west|-0,-6.25) to (\b.south east|-0,-6.25);
        }
    \foreach[count=\i] \p in {Zero,Four,Seven,Eleven,Nineteen} {
        \node[scale=.33,above] (\i) at (1.25*\i, -7.5) {\expandafter\usebox\csname PinguMs\p\endcsname};
    }}
\end{tikzpicture}}
\end{columns}
\begin{tikzpicture}[remember picture,overlay]
    \onslide<15->{%
        \node[above right=.25cm,yshift=1cm,scale=.6] (pingu) at (current page.south west) {\usebox\pinguA};
        \node[above=1mm,scale=.6,text width=4.5cm,align=center,font=\footnotesize\sffamily] at(pingu.north) {%
Wir werden nur den \textit{aufsteigenden} Fall betrachten. Ein Beispiel für die Hordeeeee\ldots
        };
    }
\end{tikzpicture}
\end{frame}
}

\SidebarReset
\subsection{In-Place}
\begin{frame}{In-Place}
\begin{itemize}[<+(1)->]
    \itemsep12pt
    \item Bedeutung variiert: \begin{itemize}
        \itemsep6pt
        \item Konstanter zusätzlicher Speicher: \(\O(1)\).\par
              \pause Eventuell auch durch Compiler-Optimierungen.
        \item Konstante zusätzliche Zeiger-/Indexzugriffe.
        \item Konstanter Speicher für die Eingabemanipulation.
        \item \ldots
    \end{itemize}
    \item Wenn nicht In-Place: \say{Out-Of-Place}.
\end{itemize}
\end{frame}

\subsection{Nichts ist umsonst}
\savebox\pinguA{\tikz{\pingu[wings wave,wings grab,name=p,eyes wink,hair=paletteB]; \shade[ball color=paletteA] (p-belly-center) circle [radius=4mm];}}%

\begin{frame}{Nichts ist umsonst}
\begin{itemize}
    \item<2-> Die Laufzeit verbessern wir durch: \begin{itemize}
        \itemsep12pt
        \item<3-> Entfernen redundanter Operationen.\smallskip\par
\begin{center}
\onslide<4->{\scalebox{.6}{\begin{tikzpicture}[baseline=.6ex]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    \draw (0,0) grid ++(6,3);
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \onslide<5->{\draw[gray!39!white,-Kite,line width=1mm,rounded corners=2pt] (.5,.5) -| ++(1,1) -| ++(-1,1) -| ++(2,-2) -| ++(1,2) -| ++(1,-2) -| ++(1,2);}
    \node[scale=.3] at(.5, .5) {\usebox\pinguA};
    \endscope
    \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \onslide<6->{\draw[line width=1mm,gray,-Kite] (current bounding box.east)++(.5,0) -- ++(1,0);
    \scope[xshift=8cm]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    \draw (0,0) grid ++(6,3);
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \draw[gray!39!white,-Kite,line width=1mm,rounded corners=2pt] (.5,.5) -| ++(5,2);
    \node[scale=.3] at(.5, .5) {\usebox\pinguA};
    \endscope
    \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \endscope}
\end{tikzpicture}}}
\end{center}
        \item<7-> Ausnutzen der Einschränkungen (z.B. nur Zahlen).\smallskip\par
\begin{center}
\onslide<8->{\scalebox{.6}{\begin{tikzpicture}[baseline=.6ex]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    \draw (0,0) grid ++(6,3);
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \onslide<9->{
        \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(0,1);
        \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(0,-1);
        \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(1,0);
        \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(-1,0);
    }
    \node[scale=.3] at(1.5, 1.5) {\usebox\pinguA};
    \endscope
    \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \onslide<10->{\draw[line width=1mm,gray,-Kite] (current bounding box.east)++(.5,0) -- ++(1,0);
    \scope[xshift=8cm]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    \draw (0,0) grid ++(6,3);
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(0,1);
    \draw[gray!39!white,-Circle,line width=1mm] (1.5,1.5) -- ++(1,0);
    \node[scale=.3] at(1.5, 1.5) {\usebox\pinguA};
    \endscope
    \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \endscope}
\end{tikzpicture}}}
\end{center}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Nichts ist umsonst\hfill\textbf{\color{shadeA}II}}
\begin{itemize}
    \item<1-> Die Laufzeit verbessern wir durch: \begin{itemize}
        \itemsep12pt
        \item<2-> Geschicktes abstrahieren (z.B. Reduktion).\smallskip\par
\begin{center}
\onslide<3->{\scalebox{.6}{\begin{tikzpicture}[baseline=.6ex]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    \draw (0,0) grid ++(6,3);
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \onslide<4->{% don't looksies at this :C
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,.5) rectangle ++(5,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,1.5) -- ++(5,0);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (1.5,.5) -- ++(0,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (2.5,.5) -- ++(0,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (3.5,.5) -- ++(0,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (4.5,.5) -- ++(0,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,.5) -- ++(2,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (1.5,.5) -- ++(2,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (2.5,.5) -- ++(2,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (3.5,.5) -- ++(2,2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,2.5) -- ++(2,-2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (1.5,2.5) -- ++(2,-2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (2.5,2.5) -- ++(2,-2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (3.5,2.5) -- ++(2,-2);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (4.5,2.5) -- ++(1,-1) -- ++(-1,-1);
        \draw[gray!39!white,line width=1mm,rounded corners=2pt] (1.5,2.5) -- ++(-1,-1) -- ++(1,-1);
    }
    \node[scale=.3] at(.5, .5) {\usebox\pinguA};
    \endscope
    \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \onslide<5->{\draw[line width=1mm,gray,-Kite] (current bounding box.east)++(.5,0) -- ++(1,0);
    \scope[xshift=8cm]
    \scope
    \clip[rounded corners=1pt] (0,0) rectangle ++(6,3);
    % \draw (0,0) grid ++(6,3);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,.5) rectangle ++(5,2);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (.5,1.5) -- ++(5,0);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (1.5,.5) -- ++(0,2);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (2.5,.5) -- ++(0,2);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (3.5,.5) -- ++(0,2);
    \draw[gray!39!white,line width=1mm,rounded corners=2pt] (4.5,.5) -- ++(0,2);
    \foreach \x in {0,1,2,3,4,5} {
        \foreach \y in {0,1,2} {
            \fill[gray!39!white] (\x+.5,\y+.5) circle [radius=1.25mm];
        }
    }
    \fill[shadeB] (5.5,2.5) circle[radius=2mm];
    \node[scale=.3] at(.5, .5) {\usebox\pinguA};
    \endscope
    % \draw[thick,rounded corners=1pt] (0,0) rectangle ++(6,3);
    \endscope}
\end{tikzpicture}}}
\end{center}
        \item<6-> Zusätzlichen Speicher (z.B. als Cache).
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}{Nichts ist umsonst\hfill\textbf{\color{shadeA}III}}
\begin{itemize}
    \itemsep12pt
    \item<1-> Die Laufzeit verbessern wir durch: \begin{itemize}
        \itemsep6pt
        \item<2-> \only<3->{\color{gray}}Entfernen redundanter Operationen.
        \item<2-> \only<3->{\color{gray}}Ausnutzen der Einschränkungen.
        \item<2-> \only<3->{\color{gray}}Geschicktes abstrahieren.
        \item<2-> \color{black}Zusätzlichen Speicher.
    \end{itemize}
    \item<4-> Gängigster Kompromiss: Speicher vs. Laufzeit.
\end{itemize}
\end{frame}

\section{Besseres Merge}
\savebox\pinguA{\tikz{\pingu[wings hug,left eye shiny,headband,eye patch right,large];}}%
% \subsection{Pointer Compare}
\SidebarFile{./InplaceMerge.java}{InplaceMerge.java}
\begin{frame}[fragile]{Zeiger-Vergleich}
\begin{columns}[c]
\column{.633\linewidth}
\lstfs{7}%
\begin{plainjava}
!*\onslide<2->*!void merge(int[] arr, int l, int m, int r) {
!*\onslide<3->*!    int l2 = m + 1;
!*\onslide<4->*!    if(arr[m] <= arr[l2]) return;
!*\onslide<5->*!    while(l <= m && l2 <= r) {
!*\onslide<6->*!        if(arr[l] <= arr[l2]) { l++; }
!*\onslide<7->*!        else { !*\onslide<8->*!// shift elements from l, 1 to right
!*\onslide<9->*!            int shift = arr[l2], idx = l2;
!*\onslide<10->*!            while(l < idx) {
!*\onslide<11->*!                arr[idx] = arr[idx - 1]; idx--;
!*\onslide<10->*!            }
!*\onslide<12->*!            arr[l] = shift;
!*\onslide<13->*!            l++; m++; l2++;
!*\onslide<7->*!}   !*\onslide<5->*!}   !*\onslide<2->*!}
\end{plainjava}
\column{.3\linewidth}
\centering
\onslide<2->{%
\resizebox\linewidth!{\begin{tikzpicture}
\foreach[count=\i]\k in {1, 7, 9, 3, 5, \ldots} {
    \node[lblock,minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \ifnum\i>1
    \draw[-Kite,gray!39!white,line width=.5mm] (\the\numexpr\i-1) -- (\i);
    \fi
}
\onslide<3->{\draw[thick,shadeA] ([yshift=1.33mm]1.north west) -- ([yshift=1.33mm]3.north east);
\draw[thick,shadeA] ([yshift=1.33mm]4.north west) -- ([yshift=1.33mm]5.north east);}
\node[below,gray] at(1.south) {l};
\onslide<3->{\node[below,gray] at(4.south) {l2};}
\node[below,gray] at(3.south) {m};
\node[below,gray] at(5.south) {r};
\end{tikzpicture}}\par}
\vspace*{.5em}\par
\onslide<4->{%
\resizebox\linewidth!{\begin{tikzpicture}
\foreach[count=\i]\k in {1, 7, 9, 3, 5, \ldots} {
    \ifnum\i=3% :C
    \node[lblock={fill=shadeA, draw=shadeA,text=black},minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \else\ifnum\i=4
    \node[lblock={fill=shadeA, draw=shadeA,text=black},minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \else
    \node[lblock,minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \fi\fi
    \ifnum\i>1
    \draw[-Kite,gray!39!white,line width=.5mm] (\the\numexpr\i-1) -- (\i);
    \fi
    \node[below,gray] at(1.south) {l};
    \node[below,gray] at(4.south) {l2};
    \node[below,gray] at(3.south) {m};
    \node[below,gray] at(5.south) {r};
}
\end{tikzpicture}}
\par}
\vspace*{.75em}\par\onslide<6->{%
\resizebox\linewidth!{\begin{tikzpicture}
\foreach[count=\i]\k in {1, 7, 9, 3, 5, \ldots} {
    \node[lblock,minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \ifnum\i>1
    \draw[-Kite,gray!39!white,line width=.5mm] (\the\numexpr\i-1) -- (\i);
    \fi
    \node[below,gray] (x) at(1.south) {\phantom{l}};
    \node[below,gray] (y) at(2.south) {l};
    \draw[-Kite,gray] (x.east) -- (y.west);
    \node[below,gray] at(4.south) {l2};
    \node[below,gray] at(3.south) {m};
    \node[below,gray] at(5.south) {r};
}
\end{tikzpicture}}
\par}
\vspace*{3em}\par\onslide<12->{%
\resizebox\linewidth!{\begin{tikzpicture}
\foreach[count=\i]\k in {1, 3, 7, 9, 5, \ldots} {
    \node[lblock,minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \ifnum\i>1
    \draw[-Kite,gray!39!white,line width=.5mm] (\the\numexpr\i-1) -- (\i);
    \fi
    \node[below,gray] (l) at(2.south) {l};
    \node[below,gray] (l2) at(4.south) {l2};
    \node[below,gray] at(3.south) {m};
    \node[below,gray] at(5.south) {r};
    \draw[-Kite,gray] ([yshift=1mm]2.north) -- ([yshift=1mm]4.north);
    \draw[-Kite,gray,rounded corners=.25mm] ([yshift=-1mm]l2.south) -- ++(0,-2.5mm) -| ([yshift=-1mm]l.south);
}
\end{tikzpicture}}
\par}
\vspace*{1.5em}\par
\onslide<13->{%
\resizebox\linewidth!{\begin{tikzpicture}
\foreach[count=\i]\k in {1, 3, 7, 9, 5, \ldots} {
    \node[lblock,minimum width=6mm] (\i) at (1.25*\i,0) {\k};
    \ifnum\i>1
    \draw[-Kite,gray!39!white,line width=.5mm] (\the\numexpr\i-1) -- (\i);
    \fi
    \node[below,gray] at(3.south) {l};
    \node[below,gray] at(5.south) {l2,r};
    \node[below,gray] at(4.south) {m};
}
\end{tikzpicture}}
\par}
\vspace*{.25em}\par
\end{columns}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<9->{%
        \node[below,xshift=-.5cm,yshift=.8cm,scale=.6] (pingu) at (current page.north east) {\rotatebox[origin=c]{135}{\usebox\pinguA}};
        \node[left=-3mm,scale=.6,text width=6.25cm,align=center,yshift=-.33cm] at (pingu.west) {Jetzt hat sich die Zeitkomplexität verschlechtert. Von \(\O(n \log n)\) auf \(\O(n^2)\).};
    }
\end{tikzpicture}%
\end{frame}
\SidebarReset

\section{Besseres Split}

\subsection{Die Verbesserung an sich}
\savebox\pinguA{\tikz{\pingu[wings shock,tie,eyes shock,headband,large];}}%
\SidebarFile{./IterativeSplit.java}{IterativeSplit.java}
\begin{frame}[fragile]{Iteratives Split}
\begin{columns}
\column{.705\linewidth}
\lstfs{8}
\begin{plainjava}
!*\onslide<2->*!void sort(int[] arr, int n) {
!*\onslide<3->*!   for (int len = 1; len <= n; len = 2*len) {
!*\onslide<4->*!      for (int left = 0; left < n; left += 2*len) {
!*\onslide<5->*!         int mid = Math.min(left + len - 1, n);
!*\onslide<6->*!         int right = Math.min(left + 2*len - 1, n);
!*\onslide<7->*!         merge(arr, left, mid, right);
!*\onslide<4->*!      }
!*\onslide<3->*!   }
!*\onslide<2->*!}
\end{plainjava}
\column{.2\linewidth}
\scriptsize\begin{enumerate}
    \itemsep12pt
    \item<9-> Beim Merge steigt die Lis\-ten\-länge getreu \(2^i\).
    \item<10-> Einstieg ist direkt bei einelementigen Listen möglich.
\end{enumerate}
\end{columns}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<8->{%
        \node[below,xshift=-.5cm,yshift=.8cm,scale=.6] (pingu) at (current page.north east) {\rotatebox[origin=c]{135}{\usebox\pinguA}};
        \node[left=-3mm,scale=.6,text width=6.25cm,align=center,yshift=-.33cm] at (pingu.west) {Und was passiert hier? Eine wilde Lüge\ldots};
    }
\end{tikzpicture}%
\end{frame}
\SidebarReset

\savebox\pinguA{%
\lstfs{8}%
\begin{minipage}{8.125cm}
\begin{plainjava}^^J
void sort(int[] arr, int n) \{^^J
{} {} {} for (int len = 1; len <= n; len = 2*len) \{^^J
{} {} {} {} {} {} for (int left = 0; left < n; left += 2*len) \{^^J
{} {} {} {} {} {} {} {} {} int mid = Math.min(left + len - 1, n);^^J
{} {} {} {} {} {} {} {} {} int right = Math.min(left + 2*len - 1, n);^^J
{} {} {} {} {} {} {} {} {} merge(arr, left, mid, right);^^J
\} {} {} {}\} {} {} \}^^J
\end{plainjava}%
\end{minipage}
}

\savebox\pinguB{\tikz{\pingu[right eye wink,sign post left={\textbf{\(\text{len}\mathbf{{}\leq n}\)\thinspace?}},left wing wave,right wing shock,bow tie=paletteB, sunglasses]}}%

\begin{frame}[c]{Iteratives Split\hfill\textbf{\color{shadeA}II}}
\hspace*{8.5em}\onslide<3->{\scalebox{.875}{\begin{tikzpicture}
\foreach[count=\i] \a in {5, 6, 9, 7, 1, 3, 4, 0} {
    \node[lblock, minimum width=6mm] (\a) at (\i, 0) {\a};
}
\onslide<4->{\foreach[count=\i] \a/\b/\c/\k in {5/6/A/{0 0 1}, 9/7/B/{2 2 3}, 1/3/C/{4 4 5}, 4/0/D/{6 6 7}}{%
    \draw[shade\c,line width=.33mm] ([yshift=1mm]\a.north west) to[edge node={node[above,gray] {\i} }] ([yshift=1mm]\a.north east);
    \draw[shade\c,line width=.33mm] ([yshift=1mm]\b.north west) to[edge node={node[above,gray!65!white,scale=.75] {\k} }] ([yshift=1mm]\b.north east);
}}
\pgfonlayer{background}
\draw[line cap=butt,gray!39!white,line width=1mm] (5.east) -- (0.west);
\endpgfonlayer
\node[right,gray,scale=.9] (len) at(0.east) {\T{len} = 1};
\onslide<7->{\scope[yshift=-16mm]
\foreach[count=\i] \a in {5, 6, 7, 9, 1, 3, 0, 4} {
    \node[lblock, minimum width=6mm] (\a) at (\i, 0) {\a};
}
\onslide<8->{\foreach[count=\i] \a/\b/\c/\d/\e/\k in {5/6/7/9/A/{0 1 3}, 1/3/0/4/B/{4 5 7}}{%
    \path[line width=.33mm] ([yshift=1mm]\a.north west) to[edge node={node[above,gray] {\i} }] ([yshift=1mm]\a.north east);
    \draw[shade\e,line width=.33mm] ([yshift=1mm]\a.north west) -- ([yshift=1mm]\b.north east);
    \draw[shade\e,line width=.33mm] ([yshift=1mm]\c.north west) to[edge node={node[above,gray!65!white,scale=.75] {\k} }] ([yshift=1mm]\d.north east);
}}
\pgfonlayer{background}
\draw[line cap=butt,gray!39!white,line width=1mm] (5.east) -- (4.west);
\endpgfonlayer
\node[right,gray,scale=.9] (len) at(4.east) {\T{len} = 2};
\endscope}
\onslide<9->{\scope[yshift=-32mm]
\foreach[count=\i] \a in {5, 6, 7, 9, 0, 1, 3, 4} {
    \node[lblock, minimum width=6mm] (\a) at (\i, 0) {\a};
}
\onslide<10->{\foreach[count=\i] \a/\b/\c/\d/\e/\k in {5/9/0/4/A/{0 3 7}}{%
    \path[line width=.33mm] ([yshift=1mm]\a.north west) to[edge node={node[above,gray] {\i} }] ([yshift=1mm]\a.north east);
    \draw[shade\e,line width=.33mm] ([yshift=1mm]\a.north west) -- ([yshift=1mm]\b.north east);
    \draw[shade\e,line width=.33mm] ([yshift=1mm]\c.north west) to[edge node={node[above,gray!65!white,scale=.75] {\k} }] ([yshift=1mm]\d.north east);
}}
\pgfonlayer{background}
\draw[line cap=butt,gray!39!white,line width=1mm] (5.east) -- (4.west);
\endpgfonlayer
\node[right,gray,scale=.9] (len) at(4.east) {\T{len} = 4};
\endscope}
\onslide<11->{\scope[yshift=-48mm]
\foreach[count=\i] \a in {0, 1, 3, 4, 5, 6, 7, 9} {
    \node[lblock, minimum width=6mm] (\a) at (\i, 0) {\a};
}
\pgfonlayer{background}
\draw[line cap=butt,gray!39!white,line width=1mm] (0.east) -- (9.west);
\endpgfonlayer
\node[right,gray,scale=.9] (len) at(9.east) {\T{len} = 8};
\endscope}
\end{tikzpicture}}}
\begin{tikzpicture}[overlay,remember picture]
    \onslide<2->{\node[above right=.25cm,yshift=.5cm,scale=.66,rounded corners=2pt,fill=gray!8!white] (cd) at (current page.south west) {\usebox\pinguA};}
    \onslide<4->{\node[above=.25cm,scale=.66,text width=\wd\pinguA,align=center] (dit) at (cd.north) {Die drei kleinen, hellgrauen Zahlen markieren die Indizes von \T{left}, \T{mid} und \T{right}.};}
    \onslide<12->{\node[scale=.4,above right,yshift=3mm] (pingu) at(dit.north west) {\usebox\pinguB};
        \node[right=.2mm,gray,scale=.66,text width=\dimexpr\wd\pinguA-.66\wd\pinguB-.2mm] at(pingu.east) {Falls das Array zu Beginn nur einen oder keinen Merge brauchen würde.};
    }
\end{tikzpicture}
\end{frame}

\subsection{Festzuhalten ist}
\begin{frame}[c]{Es bleibt festzuhalten\ldots}
\begin{itemize}[<+(1)->]
    \itemsep12pt
    \item Der zusätzliche Speicher ist nun gänzlich in \(\O(1)\).
    \item Aber die Laufzeit ist nun in \(\O(n^2)\).\smallskip\par
    \begin{itemize}
        \itemsep6pt
        \item Dazu trägt der iterative Sort nur \(\O(n \log n)\) bei.
        \item Die Komplexität entspringt dem Merge\ldots
    \end{itemize}
\end{itemize}
\end{frame}
\section{Abschluss}
\SidebarCite{dive:merge-sorted-arrays}
\SidebarCite{book:algorithms}
\SidebarCite{dive:parallel-merge}
\begin{frame}{Abschließendes}
\begin{itemize}[<+(1)->]
    \itemsep12pt
    \item Wir werden es (vermutlich) nicht unter \(\O(n \log^2(n))\) schaffen.
    \item Das erreichen wir durch eine effiziente Shell-Sort-Inspiration, welcher den Merge ersetzen soll.
\end{itemize}
\end{frame}
\SidebarReset
\end{document}
